using System.Collections.Generic;

namespace PascalCompiler
{
    public partial class Tokenizer
    {
        public enum TokenType
        {
            ReservedWord,
            Identifier,
            Operator,
            Separator,
            Constant,
            EndOfFile
        }

        public enum TokenSubType
        {
            Identifier,
            // Special symbols
            Plus,
            Minus,
            Asterisk,
            Slash,
            Equal,
            Less,
            More,
            LBracket,
            RBracket,
            Dot,
            Comma,
            LParenthesis,
            RParenthesis,
            Colon,
            Semicolon,
            AddressOf,
            Power,
            NEqual,
            SymDiff,
            LEqual,
            GEqual,
            Assign,
            PlusAssign,
            MinusAssign,
            AsteriskAssign,
            SlashAssign,
            // Reserved words (Turbo Pascal)
            Absolute,
            And,
            Array,
            Asm,
            Begin,
            Case,
            Const,
            Constructor,
            Destructor,
            Div,
            Do,
            Downto,
            Else,
            End,
            File,
            For,
            Function,
            Goto,
            If,
            Implementation,
            In,
            Inherited,
            Inline,
            Interface,
            Label,
            Mod,
            Nil,
            Not,
            Object,
            Of,
            Operator,
            Or,
            Packed,
            Procedure,
            Program,
            Record,
            Reintroduce,
            Repeat,
            Self,
            Set,
            Shl,
            Shr,
            String,
            Then,
            To,
            Type,
            Unit,
            Until,
            Uses,
            Var,
            While,
            With,
            Xor,
            // Reserved words (Object Pascal)
            As,
            Class,
            Dispinterface,
            Except,
            Exports,
            Finalization,
            Finally,
            Initialization,
            // Inline, // Was already defined
            Is,
            Library,
            On,
            Out,
            // Packed, // Was already defined
            Property,
            Raise,
            Resourcestring,
            Threadvar,
            Try,
            // Some other tokens
            IntegerConstant,
            FloatConstant,
            StringConstant,
            Range,
            // Hint directives
            Deprecated,
            Experimental,
            Platform,
            Unimplemented,
            // EOF
            EndOfFile,
            // Read/write
            Read,
            Write,
        }

        private readonly Dictionary<string, TokenSubType> TokenSubTypeDict = new Dictionary<string, TokenSubType>
        {
            {"+", TokenSubType.Plus },
            {"-", TokenSubType.Minus },
            {"*", TokenSubType.Asterisk },
            {"/", TokenSubType.Slash },
            {"=", TokenSubType.Equal },
            {"<", TokenSubType.Less },
            {">", TokenSubType.More },
            {"[", TokenSubType.LBracket },
            {"]", TokenSubType.RBracket },
            {"(.", TokenSubType.LBracket },
            {".)", TokenSubType.RBracket },
            {".", TokenSubType.Dot },
            {",", TokenSubType.Comma },
            {"(", TokenSubType.LParenthesis },
            {")", TokenSubType.RParenthesis },
            {":", TokenSubType.Colon },
            {";", TokenSubType.Semicolon },
            {"^", TokenSubType.AddressOf },
            {"@", TokenSubType.AddressOf },
            {"<<", TokenSubType.Shl },
            {"shl", TokenSubType.Shl },
            {">>", TokenSubType.Shr },
            {"shr", TokenSubType.Shr },
            {"**", TokenSubType.Power },
            {"<>", TokenSubType.NEqual },
            {"><", TokenSubType.SymDiff },
            {"<=", TokenSubType.LEqual },
            {">=", TokenSubType.GEqual },
            {":=", TokenSubType.Assign },
            {"+=", TokenSubType.PlusAssign },
            {"-=", TokenSubType.MinusAssign },
            {"*=", TokenSubType.AsteriskAssign },
            {"/=", TokenSubType.SlashAssign },
            {"..", TokenSubType.Range },
            {"absolute", TokenSubType.Absolute },
            {"and", TokenSubType.And },
            {"array", TokenSubType.Array },
            {"asm", TokenSubType.Asm },
            {"begin", TokenSubType.Begin },
            {"case", TokenSubType.Case },
            {"const", TokenSubType.Const },
            {"constructor", TokenSubType.Constructor },
            {"destructor", TokenSubType.Destructor },
            {"div", TokenSubType.Div },
            {"do", TokenSubType.Do },
            {"downto", TokenSubType.Downto },
            {"else", TokenSubType.Else },
            {"end", TokenSubType.End },
            {"file", TokenSubType.File },
            {"for", TokenSubType.For },
            {"function", TokenSubType.Function },
            {"goto", TokenSubType.Goto },
            {"if", TokenSubType.If },
            {"implementation", TokenSubType.Implementation },
            {"in", TokenSubType.In },
            {"inherited", TokenSubType.Inherited },
            {"inline", TokenSubType.Inline },
            {"interface", TokenSubType.Interface },
            {"label", TokenSubType.Label },
            {"mod", TokenSubType.Mod },
            {"nil", TokenSubType.Nil },
            {"not", TokenSubType.Not },
            {"object", TokenSubType.Object },
            {"of", TokenSubType.Of },
            {"operator", TokenSubType.Operator },
            {"or", TokenSubType.Or },
            {"packed", TokenSubType.Packed },
            {"procedure", TokenSubType.Procedure },
            {"program", TokenSubType.Program },
            {"record", TokenSubType.Record },
            {"reintroduce", TokenSubType.Reintroduce },
            {"repeat", TokenSubType.Repeat },
            {"self", TokenSubType.Self },
            {"set", TokenSubType.Set },
            {"string", TokenSubType.String },
            {"then", TokenSubType.Then },
            {"to", TokenSubType.To },
            {"type", TokenSubType.Type },
            {"unit", TokenSubType.Unit },
            {"until", TokenSubType.Until },
            {"uses", TokenSubType.Uses },
            {"var", TokenSubType.Var },
            {"while", TokenSubType.While },
            {"with", TokenSubType.With },
            {"xor", TokenSubType.Xor },
            {"as", TokenSubType.As },
            {"class", TokenSubType.Class },
            {"dispinterface", TokenSubType.Dispinterface },
            {"except", TokenSubType.Except },
            {"exports", TokenSubType.Exports },
            {"finalization", TokenSubType.Finalization },
            {"finally", TokenSubType.Finally },
            {"initialization", TokenSubType.Initialization },
            {"is", TokenSubType.Is },
            {"library", TokenSubType.Library },
            {"on", TokenSubType.On },
            {"out", TokenSubType.Out },
            {"property", TokenSubType.Property },
            {"raise", TokenSubType.Raise },
            {"resourcestring", TokenSubType.Resourcestring },
            {"threadvar", TokenSubType.Threadvar },
            {"try", TokenSubType.Try },
            {"deprecated", TokenSubType.Deprecated },
            {"experimental", TokenSubType.Experimental },
            {"platform", TokenSubType.Platform },
            {"unimplemented", TokenSubType.Unimplemented },
            {"read", TokenSubType.Read },
            {"write", TokenSubType.Write },
        };
    }
}
